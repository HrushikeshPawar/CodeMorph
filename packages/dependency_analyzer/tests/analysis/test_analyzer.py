from __future__ import annotations
import pytest
import networkx as nx
import loguru as lg # Use a concrete logger for testing
from typing import List, Dict, Any

# Assuming plsql_analyzer is a package accessible in the Python path.
from plsql_analyzer.core.code_object import CodeObjectType, PLSQL_CodeObject
from plsql_analyzer.parsing.call_extractor import CallDetailsTuple # Added for MockPLSQLCodeObject

# Functions to test
from dependency_analyzer.analysis.analyzer import (
    find_unused_objects,
    find_circular_dependencies,
    generate_subgraph_for_node,
    find_entry_points,
    find_terminal_nodes,
    get_node_degrees,
    find_all_paths,
    get_connected_components,
    calculate_node_complexity_metrics,
    get_descendants,
    get_ancestors,
    trace_downstream_paths
)

class MockPLSQLCodeObject(PLSQL_CodeObject):
    # Override init to allow easier mock creation if MockPLSQLCodeObject has complex setup
    def __init__(
        self,
        name: str,
        type: CodeObjectType = CodeObjectType.UNKNOWN,
        package_name: str = "SomePackageName",
        clean_code: str | None = "BEGIN null; END;", # Default clean_code
        parsed_parameters: List[Dict[str, Any]] | None = None,
        extracted_calls: List[CallDetailsTuple] | None = None,
        overloaded: bool = False,
        id: str | None = None, # Allow explicit ID setting
        **kwargs # Allow other MockPLSQLCodeObject params if needed
    ):
        effective_package_name = package_name if package_name is not None else ""
        # Call super with all relevant parameters.
        # MockPLSQLCodeObject handles casefolding of name and package_name.
        super().__init__(
            name=name,
            package_name=effective_package_name,
            type=type,
            clean_code=clean_code,
            parsed_parameters=parsed_parameters,
            extracted_calls=extracted_calls,
            overloaded=overloaded,
            **kwargs
        )
        # If an explicit ID is provided for the test, set it after super().__init__
        # to ensure it overrides any ID generated by the superclass.
        if id:
            self.id = id
        elif not self.id: # If super() didn't set an ID (e.g. not overloaded with params)
                           # or if an explicit id was not given, ensure one is generated.
            self.generate_id() # Ensure ID is generated based on name/package

    # Helper to easily add a call (optional for these tests, but kept for consistency)
    def add_call(self, call_name: str, line_no: int = 1, pos_params: List[str] | None = None, named_params: Dict[str, str] | None = None):
        if self.extracted_calls is None:
            self.extracted_calls = []
        self.extracted_calls.append(
            CallDetailsTuple(
                call_name=call_name,
                line_no=line_no,
                start_idx=0, # Dummy value
                end_idx=0,   # Dummy value
                positional_params=pos_params if pos_params is not None else [],
                named_params=named_params if named_params is not None else {}
            )
        )


# --- Fixtures ---
@pytest.fixture
def empty_graph() -> nx.DiGraph:
    """Returns an empty graph."""
    return nx.DiGraph()

@pytest.fixture
def simple_graph_no_cycles() -> nx.DiGraph:
    """
    A simple graph:
    A -> B
    B -> C
    D (isolated)
    E -> F
    """
    graph = nx.DiGraph()
    nodes_data = {
        "A": {"object": MockPLSQLCodeObject(name="A", type=CodeObjectType.PROCEDURE)},
        "B": {"object": MockPLSQLCodeObject(name="B", type=CodeObjectType.PROCEDURE)},
        "C": {"object": MockPLSQLCodeObject(name="C", type=CodeObjectType.FUNCTION)},
        "D": {"object": MockPLSQLCodeObject(name="D", type=CodeObjectType.PACKAGE)},
        "E": {"object": MockPLSQLCodeObject(name="E", type=CodeObjectType.PROCEDURE)},
        "F": {"object": MockPLSQLCodeObject(name="F", type=CodeObjectType.PROCEDURE)},
    }
    for node_id, data in nodes_data.items():
        graph.add_node(node_id, **data)
    graph.add_edges_from([("A", "B"), ("B", "C"), ("E", "F")])
    return graph

@pytest.fixture
def graph_with_cycles() -> nx.DiGraph:
    """
    Graph with cycles:
    A -> B
    B -> C
    C -> A (Cycle A-B-C)
    D -> E
    E -> D (Cycle D-E)
    F -> G
    G -> H (No cycle here)
    A -> D (connects the two cycle components)
    """
    graph = nx.DiGraph()
    nodes_data = {
        "A": {"object": MockPLSQLCodeObject(name="A")}, "B": {"object": MockPLSQLCodeObject(name="B")},
        "C": {"object": MockPLSQLCodeObject(name="C")}, "D": {"object": MockPLSQLCodeObject(name="D")},
        "E": {"object": MockPLSQLCodeObject(name="E")}, "F": {"object": MockPLSQLCodeObject(name="F")},
        "G": {"object": MockPLSQLCodeObject(name="G")}, "H": {"object": MockPLSQLCodeObject(name="H")},
    }
    for node_id, data in nodes_data.items():
        graph.add_node(node_id, **data)
    graph.add_edges_from([
        ("A", "B"), ("B", "C"), ("C", "A"),
        ("D", "E"), ("E", "D"),
        ("F", "G"), ("G", "H"),
        ("A", "D")
    ])
    return graph

@pytest.fixture
def graph_with_placeholders() -> nx.DiGraph:
    """
    Graph with placeholder nodes (UNKNOWN type):
    A -> P1 (Placeholder)
    B -> X (Normal)
    X -> P2 (Placeholder)
    P3 (Placeholder, isolated)
    """
    graph = nx.DiGraph()
    nodes_data = {
        "A": {"object": MockPLSQLCodeObject(name="A", type=CodeObjectType.PROCEDURE)},
        "P1": {"object": MockPLSQLCodeObject(name="P1", type=CodeObjectType.UNKNOWN)},
        "B": {"object": MockPLSQLCodeObject(name="B", type=CodeObjectType.PROCEDURE)},
        "X": {"object": MockPLSQLCodeObject(name="X", type=CodeObjectType.FUNCTION)},
        "P2": {"object": MockPLSQLCodeObject(name="P2", type=CodeObjectType.UNKNOWN)},
        "P3": {"object": MockPLSQLCodeObject(name="P3", type=CodeObjectType.UNKNOWN)},
    }
    for node_id, data in nodes_data.items():
        graph.add_node(node_id, **data)
    graph.add_edges_from([("A", "P1"), ("B", "X"), ("X", "P2")])
    return graph

@pytest.fixture
def complex_graph() -> nx.DiGraph:
    """
    A more complex graph for thorough testing:
    - Entry points: EntryA, EntryB
    - Cycles: C1-C2-C3-C1
    - Placeholders: P1, P2
    - Terminals (non-placeholder): T1
    - Isolated: Iso
    EntryA -> MidA -> C1
    EntryA -> P1
    C1 -> C2 -> C3 -> C1
    C2 -> MidB
    MidB -> T1
    MidB -> P2
    EntryB (no outgoing edges within this graph, but could be called)
    Iso (no in or out edges)
    """
    graph = nx.DiGraph()
    nodes_data = {
        "EntryA": {"object": MockPLSQLCodeObject(name="EntryA", type=CodeObjectType.PROCEDURE)},
        "EntryB": {"object": MockPLSQLCodeObject(name="EntryB", type=CodeObjectType.PROCEDURE)},
        "MidA": {"object": MockPLSQLCodeObject(name="MidA", type=CodeObjectType.FUNCTION)},
        "C1": {"object": MockPLSQLCodeObject(name="C1")},
        "C2": {"object": MockPLSQLCodeObject(name="C2")},
        "C3": {"object": MockPLSQLCodeObject(name="C3")},
        "MidB": {"object": MockPLSQLCodeObject(name="MidB")},
        "T1": {"object": MockPLSQLCodeObject(name="T1", type=CodeObjectType.PROCEDURE)}, # Terminal
        "P1": {"object": MockPLSQLCodeObject(name="P1", type=CodeObjectType.UNKNOWN)},   # Placeholder
        "P2": {"object": MockPLSQLCodeObject(name="P2", type=CodeObjectType.UNKNOWN)},   # Placeholder
        "Iso": {"object": MockPLSQLCodeObject(name="Iso", type=CodeObjectType.PACKAGE)}, # Isolated
    }
    for node_id, data in nodes_data.items():
        graph.add_node(node_id, **data)

    graph.add_edges_from([
        ("EntryA", "MidA"), ("EntryA", "P1"),
        ("MidA", "C1"),
        ("C1", "C2"), ("C2", "C3"), ("C3", "C1"), # Cycle
        ("C2", "MidB"),
        ("MidB", "T1"), ("MidB", "P2")
    ])
    return graph

# --- Test Cases ---

# 1. find_unused_objects
def test_find_unused_objects_empty_graph(empty_graph, da_test_logger: lg.Logger):
    assert find_unused_objects(empty_graph, da_test_logger) == set()

def test_find_unused_objects_simple_graph(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # A, D, E have in-degree 0
    expected = {"A", "D", "E"}
    assert find_unused_objects(simple_graph_no_cycles, da_test_logger) == expected

def test_find_unused_objects_with_cycles(graph_with_cycles, da_test_logger: lg.Logger):
    # F has in-degree 0. A is part of a cycle but also an entry to D.
    # A has in_degree 0 (from outside perspective, C->A is internal to cycle)
    # D has in_degree 1 (from A)
    # F has in_degree 0
    # expected = {"A", "F"} # A is an entry to its component, F is an entry to its.
    # Correcting: nx.simple_cycles finds elementary cycles.
    # In-degree of A is 1 (from C). In-degree of D is 1 (from A). In-degree of F is 0.
    # The function looks for nodes with in_degree == 0.
    # For graph_with_cycles:
    # A: in_degree from C = 1
    # B: in_degree from A = 1
    # C: in_degree from B = 1
    # D: in_degree from A, E = 2
    # E: in_degree from D = 1
    # F: in_degree = 0
    # G: in_degree from F = 1
    # H: in_degree from G = 1
    assert find_unused_objects(graph_with_cycles, da_test_logger) == {"F"}

def test_find_unused_objects_complex_graph(complex_graph, da_test_logger: lg.Logger):
    # EntryA, EntryB, Iso have in-degree 0
    expected = {"EntryA", "EntryB", "Iso"}
    assert find_unused_objects(complex_graph, da_test_logger) == expected


# 2. find_circular_dependencies
def test_find_circular_dependencies_empty_graph(empty_graph, da_test_logger: lg.Logger):
    assert find_circular_dependencies(empty_graph, da_test_logger) == []

def test_find_circular_dependencies_no_cycles(simple_graph_no_cycles, da_test_logger: lg.Logger):
    assert find_circular_dependencies(simple_graph_no_cycles, da_test_logger) == []

def test_find_circular_dependencies_with_cycles(graph_with_cycles, da_test_logger: lg.Logger):
    cycles = find_circular_dependencies(graph_with_cycles, da_test_logger)
    # Convert lists of nodes to sets of frozensets for order-independent comparison
    # Expected cycles: (A, B, C) and (D, E)
    expected_cycles_sets = {
        frozenset(["A", "B", "C"]),
        frozenset(["D", "E"])
    }
    found_cycles_sets = {frozenset(cycle) for cycle in cycles}
    assert found_cycles_sets == expected_cycles_sets

def test_find_circular_dependencies_complex_graph(complex_graph, da_test_logger: lg.Logger):
    cycles = find_circular_dependencies(complex_graph, da_test_logger)
    expected_cycles_sets = {frozenset(["C1", "C2", "C3"])}
    found_cycles_sets = {frozenset(cycle) for cycle in cycles}
    assert found_cycles_sets == expected_cycles_sets


# 3. generate_subgraph_for_node
def test_generate_subgraph_empty_graph(empty_graph, da_test_logger: lg.Logger):
    # Test with an empty graph
    subgraph = generate_subgraph_for_node(empty_graph, "A", da_test_logger)
    assert subgraph is None, "Subgraph should be None for an empty graph"

def test_generate_subgraph_node_not_found(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # Test when the node_id is not in the graph
    subgraph = generate_subgraph_for_node(simple_graph_no_cycles, "Z", da_test_logger)
    assert subgraph is None, "Subgraph should be None if node_id is not found"

def test_generate_subgraph_default_depths_simple_graph(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # Test with default upstream_depth=1 and downstream_depth=None (all downstream)
    # For simple_graph_no_cycles: A -> B -> C; D (isolated); E -> F
    # Starting at "A", upstream_depth=0 (only "A" itself), downstream_depth=None
    # Expected: "A", "B", "C"
    subgraph = generate_subgraph_for_node(simple_graph_no_cycles, "A", da_test_logger, upstream_depth=0)
    assert subgraph is not None
    expected_nodes = {"A", "B", "C"}
    assert set(subgraph.nodes()) == expected_nodes, f"Expected nodes {expected_nodes}, got {set(subgraph.nodes())}"
    assert subgraph.has_edge("A", "B")
    assert subgraph.has_edge("B", "C")
    assert subgraph.number_of_edges() == 2

def test_generate_subgraph_default_depths_from_middle_node(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # Start at "B": A -> B -> C
    # upstream_depth=1 (default): "A"
    # downstream_depth=None (default): "C"
    # Expected: "A", "B", "C"
    subgraph = generate_subgraph_for_node(simple_graph_no_cycles, "B", da_test_logger)
    assert subgraph is not None
    expected_nodes = {"A", "B", "C"}
    assert set(subgraph.nodes()) == expected_nodes, f"Expected nodes {expected_nodes}, got {set(subgraph.nodes())}"
    assert subgraph.has_edge("A", "B")
    assert subgraph.has_edge("B", "C")
    assert subgraph.number_of_edges() == 2

def test_generate_subgraph_specific_downstream_depth(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # Start at "A": A -> B -> C; (D is isolated); E -> F
    # upstream_depth=0
    # downstream_depth=1
    # Expected: "A", "B" (D is not connected from A, E is a separate chain)
    subgraph = generate_subgraph_for_node(simple_graph_no_cycles, "A", da_test_logger, upstream_depth=0, downstream_depth=1)
    assert subgraph is not None
    expected_nodes = {"A", "B"}
    assert set(subgraph.nodes()) == expected_nodes, f"Expected nodes {expected_nodes}, got {set(subgraph.nodes())}"
    assert subgraph.has_edge("A", "B")
    assert subgraph.number_of_edges() == 1, f"Expected 1 edge, got {subgraph.number_of_edges()}"


def test_generate_subgraph_specific_upstream_depth(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # Start at "C": A -> B -> C
    # upstream_depth=1: "B"
    # downstream_depth=0: "C" itself
    # Expected: "B", "C"
    subgraph = generate_subgraph_for_node(simple_graph_no_cycles, "C", da_test_logger, upstream_depth=1, downstream_depth=0)
    assert subgraph is not None
    expected_nodes = {"B", "C"}
    assert set(subgraph.nodes()) == expected_nodes, f"Expected nodes {expected_nodes}, got {set(subgraph.nodes())}"
    assert subgraph.has_edge("B", "C")
    assert subgraph.number_of_edges() == 1

def test_generate_subgraph_full_downstream_complex(complex_graph, da_test_logger: lg.Logger):
    # complex_graph: EntryA -> MidA -> C1; EntryA -> P1; C1-C2-C3-C1; C2 -> MidB; MidB -> T1; MidB -> P2
    # Start at "MidA", upstream_depth=1 ("EntryA"), downstream_depth=None (C1, C2, C3, MidB, T1, P2)
    # Expected nodes: "EntryA", "MidA", "C1", "C2", "C3", "MidB", "T1", "P2"
    subgraph = generate_subgraph_for_node(complex_graph, "MidA", da_test_logger, upstream_depth=1) # downstream_depth=None by default
    assert subgraph is not None
    expected_nodes = {"EntryA", "MidA", "C1", "C2", "C3", "MidB", "T1", "P2"}
    assert set(subgraph.nodes()) == expected_nodes, f"Expected nodes {expected_nodes}, got {set(subgraph.nodes())}"
    # Check some key edges
    assert subgraph.has_edge("EntryA", "MidA")
    assert subgraph.has_edge("MidA", "C1")
    assert subgraph.has_edge("C1", "C2")
    assert subgraph.has_edge("C2", "C3")
    assert subgraph.has_edge("C3", "C1") # Cycle part
    assert subgraph.has_edge("C2", "MidB")
    assert subgraph.has_edge("MidB", "T1")
    assert subgraph.has_edge("MidB", "P2")
    assert not subgraph.has_node("P1") # P1 is downstream of EntryA, not MidA for this test.
    assert not subgraph.has_node("EntryB")
    assert not subgraph.has_node("Iso")


def test_generate_subgraph_limited_downstream_complex(complex_graph, da_test_logger: lg.Logger):
    # complex_graph: EntryA -> MidA -> C1; EntryA -> P1; C1-C2-C3-C1; C2 -> MidB; MidB -> T1; MidB -> P2
    # Start at "EntryA", upstream_depth=0, downstream_depth=1 ("MidA", "P1")
    # Expected nodes: "EntryA", "MidA", "P1"
    subgraph = generate_subgraph_for_node(complex_graph, "EntryA", da_test_logger, upstream_depth=0, downstream_depth=1)
    assert subgraph is not None
    expected_nodes = {"EntryA", "MidA", "P1"}
    assert set(subgraph.nodes()) == expected_nodes, f"Expected nodes {expected_nodes}, got {set(subgraph.nodes())}"
    assert subgraph.has_edge("EntryA", "MidA")
    assert subgraph.has_edge("EntryA", "P1")
    assert not subgraph.has_node("C1") # C1 should be excluded by downstream_depth=1 from EntryA

def test_generate_subgraph_zero_upstream_full_downstream(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # Start at "A": A -> B -> C; (D is isolated); E -> F
    # upstream_depth=0
    # downstream_depth=None (all downstream from A)
    # Expected: "A", "B", "C"
    subgraph = generate_subgraph_for_node(simple_graph_no_cycles, "A", da_test_logger, upstream_depth=0, downstream_depth=None)
    assert subgraph is not None
    expected_nodes = {"A", "B", "C"}
    assert set(subgraph.nodes()) == expected_nodes
    assert subgraph.number_of_nodes() == 3
    assert subgraph.number_of_edges() == 2 # A->B, B->C

def test_generate_subgraph_zero_downstream_full_upstream(graph_with_cycles, da_test_logger: lg.Logger):
    # graph_with_cycles: A->B, B->C, C->A (cycle A-B-C), A->D, D->E, E->D (cycle D-E)
    # Start at "D", upstream_depth=5 (simulating all: A, C, B, E), downstream_depth=0
    # Expected: "A", "B", "C", "D", "E"
    subgraph = generate_subgraph_for_node(graph_with_cycles, "D", da_test_logger, upstream_depth=5, downstream_depth=0)
    assert subgraph is not None
    # A calls D. C calls A. B calls C. E calls D.
    # So from D, upstream includes A, E, C, B
    expected_nodes = {"A", "B", "C", "D", "E"}
    assert set(subgraph.nodes()) == expected_nodes, f"Expected {expected_nodes}, got {set(subgraph.nodes())}"
    assert subgraph.has_edge("A", "D")
    assert subgraph.has_edge("E", "D")
    assert subgraph.has_edge("C", "A")
    assert subgraph.has_edge("B", "C")
    assert subgraph.has_edge("A", "B") # This is part of the A-B-C cycle, so it's included
    # Total edges: A->D, E->D, C->A, B->C, A->B = 5 and # D-> E (cycle)  +1
    da_test_logger.debug(f"Subgraph edges: {subgraph.edges()}")
    assert subgraph.number_of_edges() == 5+1


def test_generate_subgraph_isolated_node(complex_graph, da_test_logger: lg.Logger):
    # complex_graph has isolated node "Iso"
    # Start at "Iso", upstream_depth=1, downstream_depth=None
    # Expected: "Iso"
    subgraph = generate_subgraph_for_node(complex_graph, "Iso", da_test_logger, upstream_depth=1, downstream_depth=None)
    assert subgraph is not None
    expected_nodes = {"Iso"}
    assert set(subgraph.nodes()) == expected_nodes
    assert subgraph.number_of_nodes() == 1
    assert subgraph.number_of_edges() == 0

def test_generate_subgraph_no_upstream_no_downstream_beyond_node(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # Start at "C": A -> B -> C
    # upstream_depth=0
    # downstream_depth=0
    # Expected: "C"
    subgraph = generate_subgraph_for_node(simple_graph_no_cycles, "C", da_test_logger, upstream_depth=0, downstream_depth=0)
    assert subgraph is not None
    expected_nodes = {"C"}
    assert set(subgraph.nodes()) == expected_nodes
    assert subgraph.number_of_nodes() == 1
    assert subgraph.number_of_edges() == 0


# 4. find_entry_points (reuses find_unused_objects logic, so tests are similar)
def test_find_entry_points_empty_graph(empty_graph, da_test_logger: lg.Logger):
    assert find_entry_points(empty_graph, da_test_logger) == set()

def test_find_entry_points_simple_graph(simple_graph_no_cycles, da_test_logger: lg.Logger):
    expected = {"A", "D", "E"}
    assert find_entry_points(simple_graph_no_cycles, da_test_logger) == expected

def test_find_entry_points_complex_graph(complex_graph, da_test_logger: lg.Logger):
    expected = {"EntryA", "EntryB", "Iso"}
    assert find_entry_points(complex_graph, da_test_logger) == expected


# 5. find_terminal_nodes
def test_find_terminal_nodes_empty_graph(empty_graph, da_test_logger: lg.Logger):
    assert find_terminal_nodes(empty_graph, da_test_logger) == set()

def test_find_terminal_nodes_simple_graph_exclude_placeholders(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # C, D, F have out-degree 0
    expected = {"C", "D", "F"}
    assert find_terminal_nodes(simple_graph_no_cycles, da_test_logger, exclude_placeholders=True) == expected

def test_find_terminal_nodes_with_placeholders_exclude(graph_with_placeholders, da_test_logger: lg.Logger):
    # P1, P2, P3 are UNKNOWN. X calls P2. B calls X. A calls P1.
    # Terminals (out-degree 0): P1, P2, P3.
    # If excluding placeholders: None are left.
    # B is not terminal (calls X). A is not (calls P1). X is not (calls P2).
    # Correct: P1, P2, P3 are terminals. If excluded, then empty set.
    assert find_terminal_nodes(graph_with_placeholders, da_test_logger, exclude_placeholders=True) == set()

def test_find_terminal_nodes_with_placeholders_include(graph_with_placeholders, da_test_logger: lg.Logger):
    expected = {"P1", "P2", "P3"}
    assert find_terminal_nodes(graph_with_placeholders, da_test_logger, exclude_placeholders=False) == expected

def test_find_terminal_nodes_complex_graph_exclude(complex_graph, da_test_logger: lg.Logger):
    # Terminals: T1, P1, P2, EntryB, Iso
    # Excluding P1, P2 (placeholders)
    expected = {"T1", "EntryB", "Iso"}
    assert find_terminal_nodes(complex_graph, da_test_logger, exclude_placeholders=True) == expected

def test_find_terminal_nodes_complex_graph_include(complex_graph, da_test_logger: lg.Logger):
    expected = {"T1", "P1", "P2", "EntryB", "Iso"}
    assert find_terminal_nodes(complex_graph, da_test_logger, exclude_placeholders=False) == expected


# 6. get_node_degrees
def test_get_node_degrees_empty_graph(empty_graph, da_test_logger: lg.Logger):
    assert get_node_degrees(empty_graph, "A", da_test_logger) is None

def test_get_node_degrees_node_not_found(simple_graph_no_cycles, da_test_logger: lg.Logger):
    assert get_node_degrees(simple_graph_no_cycles, "Z", da_test_logger) is None

def test_get_node_degrees_simple_graph(simple_graph_no_cycles, da_test_logger: lg.Logger):
    degrees_B = get_node_degrees(simple_graph_no_cycles, "B", da_test_logger)
    assert degrees_B == {"in_degree": 1, "out_degree": 1, "total_degree": 2}
    degrees_D = get_node_degrees(simple_graph_no_cycles, "D", da_test_logger)
    assert degrees_D == {"in_degree": 0, "out_degree": 0, "total_degree": 0}

def test_get_node_degrees_complex_graph(complex_graph, da_test_logger: lg.Logger):
    degrees_C2 = get_node_degrees(complex_graph, "C2", da_test_logger) # C1->C2, C2->C3, C2->MidB
    assert degrees_C2 == {"in_degree": 1, "out_degree": 2, "total_degree": 3}
    degrees_EntryA = get_node_degrees(complex_graph, "EntryA", da_test_logger) # EntryA->MidA, EntryA->P1
    assert degrees_EntryA == {"in_degree": 0, "out_degree": 2, "total_degree": 2}
    degrees_P1 = get_node_degrees(complex_graph, "P1", da_test_logger) # EntryA->P1
    assert degrees_P1 == {"in_degree": 1, "out_degree": 0, "total_degree": 1}


# 7. find_all_paths
def test_find_all_paths_empty_graph(empty_graph, da_test_logger: lg.Logger):
    assert find_all_paths(empty_graph, "A", "B", da_test_logger) is None

def test_find_all_paths_nodes_not_found(simple_graph_no_cycles, da_test_logger: lg.Logger):
    assert find_all_paths(simple_graph_no_cycles, "A", "Z", da_test_logger) is None
    assert find_all_paths(simple_graph_no_cycles, "Z", "A", da_test_logger) is None

def test_find_all_paths_no_path(simple_graph_no_cycles, da_test_logger: lg.Logger):
    assert find_all_paths(simple_graph_no_cycles, "A", "D", da_test_logger) == []

def test_find_all_paths_simple_path(simple_graph_no_cycles, da_test_logger: lg.Logger):
    paths = find_all_paths(simple_graph_no_cycles, "A", "C", da_test_logger)
    assert paths == [["A", "B", "C"]]

def test_find_all_paths_same_source_target(simple_graph_no_cycles, da_test_logger: lg.Logger):
    paths = find_all_paths(simple_graph_no_cycles, "A", "A", da_test_logger)
    assert paths == [["A"]]

def test_find_all_paths_with_cycles_and_cutoff(graph_with_cycles, da_test_logger: lg.Logger):
    # A -> B -> C -> A (cycle)
    # A -> D -> E -> D (cycle)
    # Path A to C: A->B->C
    # Path A to E: A->D->E
    paths_A_C = find_all_paths(graph_with_cycles, "A", "C", da_test_logger)
    assert [["A", "B", "C"]] == paths_A_C # nx.all_simple_paths

    paths_A_E = find_all_paths(graph_with_cycles, "A", "E", da_test_logger)
    assert [["A", "D", "E"]] == paths_A_E

    # Test cutoff
    # A -> B -> C. Length 3 (2 edges). Cutoff 2 means max 2 edges.
    paths_A_C_cutoff2 = find_all_paths(graph_with_cycles, "A", "C", da_test_logger, cutoff=1)
    assert paths_A_C_cutoff2 == [] # Path A-B-C has length 3 (nodes), 2 edges. Cutoff 1 should yield no path.
    paths_A_C_cutoff3 = find_all_paths(graph_with_cycles, "A", "C", da_test_logger, cutoff=2)
    assert paths_A_C_cutoff3 == [["A", "B", "C"]]

def test_find_all_paths_complex_multiple_paths(complex_graph, da_test_logger: lg.Logger):
    # Paths from EntryA to MidB:
    # 1. EntryA -> MidA -> C1 -> C2 -> MidB
    paths = find_all_paths(complex_graph, "EntryA", "MidB", da_test_logger)
    expected_paths = [
        ["EntryA", "MidA", "C1", "C2", "MidB"]
    ]
    # Convert to set of tuples for order-independent comparison of paths
    assert {tuple(p) for p in paths} == {tuple(ep) for ep in expected_paths}


# 7b. trace_downstream_paths
def test_trace_downstream_paths_to_target(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # Graph: A -> B -> C, D, E -> F
    # Paths from A to C: [["A", "B", "C"]]
    paths = trace_downstream_paths(simple_graph_no_cycles, "A", da_test_logger, target_node="C")
    assert paths == [["A", "B", "C"]]

def test_trace_downstream_paths_depth_limit(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # Paths from A, depth_limit=1: [["A", "B"]]
    paths = trace_downstream_paths(simple_graph_no_cycles, "A", da_test_logger, depth_limit=1)
    assert paths == [["A", "B"]]
    # Paths from A, depth_limit=2: [["A", "B"], ["A", "B", "C"]]
    paths = trace_downstream_paths(simple_graph_no_cycles, "A", da_test_logger, depth_limit=2)
    assert sorted(paths) == sorted([["A", "B"], ["A", "B", "C"]])

def test_trace_downstream_paths_no_target_all_paths(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # All simple paths from E: [["E", "F"]]
    paths = trace_downstream_paths(simple_graph_no_cycles, "E", da_test_logger)
    assert paths == [["E", "F"]]
    # All simple paths from D: [] (no outgoing edges)
    paths = trace_downstream_paths(simple_graph_no_cycles, "D", da_test_logger)
    assert paths == []

def test_trace_downstream_paths_cycles(graph_with_cycles, da_test_logger: lg.Logger):
    # A -> B -> C -> A (cycle), A -> D -> E -> D (cycle)
    # All simple paths from A, depth_limit=3
    paths = trace_downstream_paths(graph_with_cycles, "A", da_test_logger, depth_limit=3)
    # Should include ["A", "B"], ["A", "B", "C"], ["A", "D"], ["A", "D", "E"]
    expected = [["A", "B"], ["A", "B", "C"], ["A", "D"], ["A", "D", "E"]]
    assert sorted(paths) == sorted(expected)

def test_trace_downstream_paths_invalid_nodes(simple_graph_no_cycles, da_test_logger: lg.Logger):
    # Source node not in graph
    paths = trace_downstream_paths(simple_graph_no_cycles, "Z", da_test_logger)
    assert paths == []
    # Target node not in graph
    paths = trace_downstream_paths(simple_graph_no_cycles, "A", da_test_logger, target_node="Z")
    assert paths == []

def test_trace_downstream_paths_empty_graph(empty_graph, da_test_logger: lg.Logger):
    paths = trace_downstream_paths(empty_graph, "A", da_test_logger)
    assert paths == []

# 8. get_connected_components
def test_get_connected_components_empty_graph(empty_graph, da_test_logger: lg.Logger):
    assert get_connected_components(empty_graph, da_test_logger, strongly_connected=True) == []
    assert get_connected_components(empty_graph, da_test_logger, strongly_connected=False) == []

def test_get_connected_components_simple_strongly(simple_graph_no_cycles, da_test_logger: lg.Logger):
    scc = get_connected_components(simple_graph_no_cycles, da_test_logger, strongly_connected=True)
    # Each node is its own SCC
    expected_scc_sets = [{"A"}, {"B"}, {"C"}, {"D"}, {"E"}, {"F"}]
    found_scc_sets = {frozenset(comp) for comp in scc}
    assert found_scc_sets == {frozenset(s) for s in expected_scc_sets}

def test_get_connected_components_simple_weakly(simple_graph_no_cycles, da_test_logger: lg.Logger):
    wcc = get_connected_components(simple_graph_no_cycles, da_test_logger, strongly_connected=False)
    # Components: (A,B,C), (D), (E,F)
    expected_wcc_sets = {frozenset(["A", "B", "C"]), frozenset(["D"]), frozenset(["E", "F"])}
    found_wcc_sets = {frozenset(comp) for comp in wcc}
    assert found_wcc_sets == expected_wcc_sets

def test_get_connected_components_cycles_strongly(graph_with_cycles, da_test_logger: lg.Logger):
    scc = get_connected_components(graph_with_cycles, da_test_logger, strongly_connected=True)
    # SCCs: (A,B,C,D,E), (F), (G), (H) because A->D connects the two cycle groups
    # Cycle A-B-C, Cycle D-E. A->D.
    # So, A,B,C,D,E are all one SCC.
    # F, G, H are separate.
    # Corrected: SCCs are {A,B,C} and {D,E} if A->D is not there.
    # With A->D:
    # A can reach D. D can reach E. E can reach D.
    # C can reach A. B can reach C. A can reach B.
    # Can D reach A? No. So {A,B,C} and {D,E} are separate SCCs.
    # {F}, {G}, {H} are also SCCs.
    expected_scc_sets = {
        frozenset(["A", "B", "C"]),
        frozenset(["D", "E"]),
        frozenset(["F"]), frozenset(["G"]), frozenset(["H"])
    }
    found_scc_sets = {frozenset(comp) for comp in scc}
    assert found_scc_sets == expected_scc_sets

def test_get_connected_components_cycles_weakly(graph_with_cycles, da_test_logger: lg.Logger):
    wcc = get_connected_components(graph_with_cycles, da_test_logger, strongly_connected=False)
    # WCCs: (A,B,C,D,E) and (F,G,H) because A->D connects them.
    expected_wcc_sets = {
        frozenset(["A", "B", "C", "D", "E"]),
        frozenset(["F", "G", "H"])
    }
    found_wcc_sets = {frozenset(comp) for comp in wcc}
    assert found_wcc_sets == expected_wcc_sets

def test_get_connected_components_complex_strongly(complex_graph, da_test_logger: lg.Logger):
    scc = get_connected_components(complex_graph, da_test_logger, strongly_connected=True)
    # SCCs: {C1,C2,C3}, {EntryA}, {MidA}, {MidB}, {T1}, {P1}, {P2}, {EntryB}, {Iso}
    expected_scc_sets = {
        frozenset(["C1", "C2", "C3"]), frozenset(["EntryA"]), frozenset(["MidA"]),
        frozenset(["MidB"]), frozenset(["T1"]), frozenset(["P1"]),
        frozenset(["P2"]), frozenset(["EntryB"]), frozenset(["Iso"])
    }
    found_scc_sets = {frozenset(comp) for comp in scc}
    assert found_scc_sets == expected_scc_sets

def test_get_connected_components_complex_weakly(complex_graph, da_test_logger: lg.Logger):
    wcc = get_connected_components(complex_graph, da_test_logger, strongly_connected=False)
    # WCCs:
    # Component 1: {EntryA, MidA, C1, C2, C3, MidB, T1, P1, P2}
    # Component 2: {EntryB}
    # Component 3: {Iso}
    expected_wcc_sets = {
        frozenset(["EntryA", "MidA", "C1", "C2", "C3", "MidB", "T1", "P1", "P2"]),
        frozenset(["EntryB"]),
        frozenset(["Iso"])
    }
    found_wcc_sets = {frozenset(comp) for comp in wcc}
    assert found_wcc_sets == expected_wcc_sets


def test_classify_nodes_basic(complex_graph, da_test_logger: lg.Logger):
    from dependency_analyzer.analysis.analyzer import classify_nodes
    classify_nodes(complex_graph, da_test_logger, complexity_metrics_available=False)
    # Check that node_role is assigned and at least one hub, utility, orphan, entry, terminal exists
    roles = {n: complex_graph.nodes[n].get('node_role', []) for n in complex_graph.nodes()}
    # There should be entry points
    entry_points = [n for n, r in roles.items() if 'entry_point' in r]
    assert set(entry_points) == {'EntryA', 'EntryB', 'Iso'}
    # There should be terminal nodes
    terminal_nodes = [n for n, r in roles.items() if 'terminal_node' in r]
    assert 'T1' in terminal_nodes and 'Iso' in terminal_nodes
    # There should be at least one hub or utility or orphan
    found_any = any('hub' in r or 'utility' in r or 'orphan_component_member' in r for r in roles.values())
    assert found_any

def test_classify_nodes_basic(complex_graph, da_test_logger: lg.Logger):
    from dependency_analyzer.analysis.analyzer import classify_nodes
    classify_nodes(complex_graph, da_test_logger, complexity_metrics_available=False)
    # Check that node_role is assigned and at least one hub, utility, orphan, entry, terminal exists
    roles = {n: complex_graph.nodes[n].get('node_role', []) for n in complex_graph.nodes()}
    # There should be entry points
    entry_points = [n for n, r in roles.items() if 'entry_point' in r]
    assert set(entry_points) == {'EntryA', 'EntryB', 'Iso'}
    # There should be terminal nodes
    terminal_nodes = [n for n, r in roles.items() if 'terminal_node' in r]
    assert 'T1' in terminal_nodes and 'Iso' in terminal_nodes
    # There should be at least one hub or utility or orphan
    found_any = any('hub' in r or 'utility' in r or 'orphan_component_member' in r for r in roles.values())
    assert found_any


# 9. calculate_node_complexity_metrics
def test_calculate_node_complexity_metrics_basic(simple_graph_no_cycles, da_test_logger: lg.Logger):
    calculate_node_complexity_metrics(simple_graph_no_cycles, da_test_logger)
    for node_id, node_data in simple_graph_no_cycles.nodes(data=True):
        assert 'loc' in node_data
        assert 'num_params' in node_data
        assert 'num_calls_made' in node_data
        assert 'acc' in node_data
        # LOC should be >= 1 for default clean_code
        assert node_data['loc'] >= 1
        # ACC should be >= 1
        assert node_data['acc'] >= 1

def test_calculate_node_complexity_metrics_edge_cases(empty_graph, da_test_logger: lg.Logger):
    # Should not raise or fail on empty graph
    calculate_node_complexity_metrics(empty_graph, da_test_logger)
    assert len(empty_graph.nodes) == 0

def test_calculate_node_complexity_metrics_complex(complex_graph, da_test_logger: lg.Logger):
    calculate_node_complexity_metrics(complex_graph, da_test_logger)
    for node_id, node_data in complex_graph.nodes(data=True):
        assert 'loc' in node_data
        assert 'num_params' in node_data
        assert 'num_calls_made' in node_data
        assert 'acc' in node_data
        # ACC should be >= 1
        assert node_data['acc'] >= 1

def test_calculate_node_complexity_metrics_specific_values(da_test_logger: lg.Logger):
    graph = nx.DiGraph()
    mock_obj_code = (
        "IF condition1 THEN\n"
        "  call_a();\n"
        "ELSIF condition2 THEN\n"
        "  call_b();\n"
        "  call_a(); -- duplicate call\n"
        "ELSE\n"
        "  FOR i IN 1..10 LOOP\n"
        "    call_c();\n"
        "  END LOOP;\n"
        "END IF;"
    )
    mock_obj_params = [{'name': 'p1', 'type': 'VARCHAR2'}, {'name': 'p2', 'type': 'NUMBER'}]
    mock_obj_calls = [
        CallDetailsTuple(call_name='call_a', line_no=2, start_idx=0, end_idx=0, positional_params=[], named_params={}),
        CallDetailsTuple(call_name='call_b', line_no=4, start_idx=0, end_idx=0, positional_params=[], named_params={}),
        CallDetailsTuple(call_name='call_a', line_no=5, start_idx=0, end_idx=0, positional_params=[], named_params={}),
        CallDetailsTuple(call_name='call_c', line_no=8, start_idx=0, end_idx=0, positional_params=[], named_params={}),
    ]
    
    mock_node_obj = MockPLSQLCodeObject(
        name="TestProc",
        clean_code=mock_obj_code,
        parsed_parameters=mock_obj_params,
        extracted_calls=mock_obj_calls
    )
    graph.add_node("TestProcNode", object=mock_node_obj)

    calculate_node_complexity_metrics(graph, da_test_logger)
    
    node_data = graph.nodes["TestProcNode"]
    assert node_data['loc'] == 10
    assert node_data['num_params'] == 2
    assert node_data['num_calls_made'] == 3 # unique: call_a, call_b, call_c
    
    # This assertion depends on whether 'THEN' is counted in ACC
    # If THEN is counted: IF, THEN, ELSIF, THEN, FOR, LOOP = 6 keywords. ACC = 6 + 1 = 7
    # If THEN is NOT counted: IF, ELSIF, FOR, LOOP = 4 keywords. ACC = 4 + 1 = 5
    expected_acc = 7 # Assuming 'THEN' is counted as per current implementation
    assert node_data['acc'] == expected_acc, f"ACC mismatch: got {node_data['acc']}, want {expected_acc}"

def test_analyze_metrics_infers_format_and_saves(tmp_path, da_test_logger):
    import shutil
    from dependency_analyzer.analysis.analyzer import calculate_node_complexity_metrics
    from dependency_analyzer.cli import analyze_metrics
    import networkx as nx
    import types
    # Create a test graph and save as .graphml
    G = nx.DiGraph()
    G.add_node("A")
    G.add_node("B")
    G.add_edge("A", "B")
    graphml_path = tmp_path / "testgraph.graphml"
    nx.write_graphml_lxml(G=G, path=graphml_path)

    # Patch analyzer.calculate_node_complexity_metrics to check call
    called = {}
    def fake_calc(graph, logger):
        called['called'] = True
        assert isinstance(graph, nx.DiGraph)
    orig_calc = calculate_node_complexity_metrics
    import dependency_analyzer.analysis.analyzer as analyzer_mod
    analyzer_mod.calculate_node_complexity_metrics = fake_calc

    # Patch GraphStorage to check format used for load/save
    from dependency_analyzer.persistence.graph_storage import GraphStorage
    orig_load_graph = GraphStorage.load_graph
    orig_save_structure_only = GraphStorage.save_structure_only
    used_formats = {}
    def fake_load(self, path, format):
        used_formats['load'] = format
        # Return a DiGraph with the expected structure for the test
        G_loaded = nx.DiGraph()
        G_loaded.add_node("A", object=None)
        G_loaded.add_node("B", object=None)
        G_loaded.add_edge("A", "B")
        return G_loaded
    def fake_save(self, graph, path, format):
        used_formats['save'] = format
        return True
    GraphStorage.load_graph = fake_load
    GraphStorage.save_structure_only = fake_save

    # Call the CLI command (simulate user passing only the file, not format)
    analyze_metrics(
        graph_path=graphml_path,
        graph_format="gpickle",  # default, should be overridden by .graphml
        verbose_level=0
    )
    assert used_formats['load'] == 'graphml'
    assert used_formats['save'] == 'graphml'
    assert called['called']

    # Restore
    analyzer_mod.calculate_node_complexity_metrics = orig_calc
    GraphStorage.load_graph = orig_load_graph
    GraphStorage.save_structure_only = orig_save_structure_only

def test_get_descendants_and_ancestors_simple(simple_graph_no_cycles):
    graph = simple_graph_no_cycles
    # A -> B -> C, D (isolated), E -> F
    assert get_descendants(graph, "A") == {"B", "C"}
    assert get_descendants(graph, "B") == {"C"}
    assert get_descendants(graph, "C") == set()
    assert get_descendants(graph, "D") == set()
    assert get_descendants(graph, "E") == {"F"}
    assert get_descendants(graph, "F") == set()
    # Depth limit
    assert get_descendants(graph, "A", depth_limit=1) == {"B"}
    assert get_descendants(graph, "A", depth_limit=2) == {"B", "C"}
    # Ancestors
    assert get_ancestors(graph, "C") == {"A", "B"}
    assert get_ancestors(graph, "B") == {"A"}
    assert get_ancestors(graph, "A") == set()
    assert get_ancestors(graph, "D") == set()
    assert get_ancestors(graph, "F") == {"E"}
    # Depth limit
    assert get_ancestors(graph, "C", depth_limit=1) == {"B"}
    assert get_ancestors(graph, "C", depth_limit=2) == {"A", "B"}
    # Node not in graph
    assert get_descendants(graph, "Z") == set()
    assert get_ancestors(graph, "Z") == set()


def test_get_descendants_and_ancestors_cycles(graph_with_cycles):
    graph = graph_with_cycles
    # A-B-C cycle, D-E cycle, F-G-H chain, A->D
    # Descendants
    assert get_descendants(graph, "A") == {"B", "C", "D", "E"}
    assert get_descendants(graph, "D") == {"E"}
    assert get_descendants(graph, "F") == {"G", "H"}
    # Ancestors
    assert get_ancestors(graph, "A") == {"B", "C"}
    assert get_ancestors(graph, "D") == {"A", "E", "B", "C"}
    assert get_ancestors(graph, "H") == {"F", "G"}
    # Depth limit
    assert get_descendants(graph, "A", depth_limit=1) == {"B", "D"}
    # C is also within 2 steps upstream of D: D<-E<-D<-A<-B<-C (cycle)
    assert get_ancestors(graph, "D", depth_limit=2) == {"A", "E", "C"}