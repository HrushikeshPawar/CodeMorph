# plsql_analyzer/core/code_object.py
import hashlib
import json # For potential serialization, though direct dict is used for DB
from enum import StrEnum, auto
from typing import List, Optional, Dict
from plsql_analyzer.parsing.call_extractor import CallDetailsTuple



class CodeObjectType(StrEnum):
    PACKAGE = auto()
    PROCEDURE = auto()
    FUNCTION = auto()
    TRIGGER = auto() # Added for potential future use
    TYPE = auto()    # Added for potential future use
    UNKNOWN = auto()


class PLSQL_CodeObject:
    def __init__(self,
                    name: str,
                    package_name: str,
                    clean_code: Optional[str] = None,
                    literal_map: Dict[str, str] = {},
                    type: Optional[CodeObjectType] = CodeObjectType.UNKNOWN,
                    overloaded: bool = False,
                    parsed_parameters: Optional[List[Dict]] = None,
                    parsed_return_type: Optional[str] = None,
                    extracted_calls: Optional[List[CallDetailsTuple]] = None, # Use the named tuple
                    # signature_raw_text: Optional[str] = None, # Store the raw signature text
                    start_line: Optional[int] = None,
                    end_line: Optional[int] = None
                ):
        
        self.name: str = name.strip().casefold()
        self.package_name: str = package_name.strip().casefold() if package_name else ""
        self.clean_code: Optional[str] =  clean_code
        self.literal_map: Optional[Dict[str, str]] = literal_map
        self.type: CodeObjectType = type
        self.overloaded: bool = overloaded
        
        self.parsed_parameters: List[Dict] = parsed_parameters if parsed_parameters is not None else []
        self.parsed_return_type: Optional[str] = parsed_return_type
        self.extracted_calls: List[CallDetailsTuple] = extracted_calls if extracted_calls is not None else []
        
        # self.signature_raw_text: Optional[str] = signature_raw_text
        self.start_line: Optional[int] = start_line
        self.end_line: Optional[int] = end_line

        self.id: Optional[str] = None # Generated by generate_id()

        self._cleanup_package_name() # Ensure name is not part of package_name

    def _cleanup_package_name(self):
        """Removes the object's own name from the package_name if present."""
        if self.package_name and self.name:
            # Handle cases like "pkg.sub_pkg.proc_name" where proc_name is the object name
            # and package_name might initially be "pkg.sub_pkg.proc_name"
            parts = self.package_name.split('.')
            if parts and parts[-1] == self.name:
                self.package_name = ".".join(parts[:-1])

    def generate_id(self):
        """
        Generates a unique ID for the code object.
        For overloaded functions/procedures, parameters are crucial.
        """
        base_id = f"{self.package_name}.{self.name}" if self.package_name else self.name
        
        if self.overloaded:
            # # For overloaded objects, include parameter types and modes in the hash
            # # to differentiate them. Sorting ensures consistent hash.
            # param_repr_parts = []
            # for p in sorted(self.parsed_parameters, key=lambda x: x.get('name', '')):
            #     param_repr_parts.append(f"{p.get('name', '')}:{p.get('type', '')}:{p.get('mode', '')}")
            # param_signature = ",".join(param_repr_parts)
            
            # Using a simpler representation of parameters for the hash part
            # self.parsed_parameters is a list of dicts.
            # Ensure consistent string representation for hashing.
            # Sort by parameter name for consistency.
            params_for_hash = sorted(self.parsed_parameters, key=lambda p: p.get('name',''))
            param_hash_str = json.dumps(params_for_hash, sort_keys=True, indent=0) # Using json.dumps for stable repr
            
            # If no parameters, it's effectively not overloaded by signature for ID purposes,
            # but the `overloaded` flag might be true if names clash but signatures differ.
            # The structural parser might set `overloaded` if it finds multiple defs with same name.
            # Here, we ensure ID reflects signature difference if params exist.
            if params_for_hash:
                self.id = f"{base_id}-{hashlib.sha256(param_hash_str.encode()).hexdigest()}"
            else:
                self.id = base_id # If overloaded but no params, ID defaults to base. This implies overload by context not signature.
        else:
            self.id = base_id
        return self.id

    def to_dict(self) -> Dict[str, str]:
        """Serializes the object to a dictionary for storage."""
        if not self.id:
            self.generate_id() # Ensure ID is generated

        return {
            'id': self.id,
            'name': self.name,
            'package_name': self.package_name,
            'type': self.type.value.upper(), # Store as uppercase string
            'overloaded': self.overloaded,
            'parsed_parameters': self.parsed_parameters, # List of dicts
            'parsed_return_type': self.parsed_return_type,
            'source_code_lines': {'start': self.start_line, 'end': self.end_line},
            # Storing source can make DB large, consider storing only if needed or path to file + lines
            'clean_code': self.clean_code,
            'literal_map': self.literal_map,
            'extracted_calls': [call._asdict() for call in self.extracted_calls] # Convert namedtuples to dicts
        }

    def __repr__(self):
        return (f"PLSQL_CodeObject(id='{self.id}', name='{self.name}', "
                f"package='{self.package_name}', type='{self.type.value}', "
                f"overloaded={self.overloaded}, "
                f"params={len(self.parsed_parameters)}, "
                f"code=<{self.clean_code.count('\n')}>, "
                f"literals={len(self.literal_map)})")
    
    @staticmethod
    def from_dict(data: Dict[str, any]) -> 'PLSQL_CodeObject':
        """
        Deserializes a dictionary back into a PLSQL_CodeObject instance.

        Args:
            data: The dictionary containing the code object's data.

        Returns:
            A PLSQL_CodeObject instance.
        """
        # Convert type string back to CodeObjectType enum
        obj_type_str = data.get('type')
        obj_type = CodeObjectType(obj_type_str.casefold()) if obj_type_str and obj_type_str.upper() in CodeObjectType.__members__ else CodeObjectType.UNKNOWN

        # Reconstruct CallDetailsTuple from list of dicts
        extracted_calls_data = data.get('extracted_calls', [])
        extracted_calls = []
        if extracted_calls_data:
            for call_dict in extracted_calls_data:
                # Ensure all fields expected by CallDetailsTuple are present
                # This assumes call_details_tuple_class constructor can handle **call_dict
                extracted_calls.append(CallDetailsTuple(**call_dict))
        
        # Handle source_code_lines if it's a nested dictionary
        source_code_lines = data.get('source_code_lines', {})
        start_line = source_code_lines.get('start')
        end_line = source_code_lines.get('end')

        # Create the object
        code_object = PLSQL_CodeObject(
            name=data['name'], # 'name' is mandatory
            package_name=data.get('package_name', ""), # Default to empty string if not present
            clean_code=data.get('clean_code'),
            literal_map=data.get('literal_map'),
            type=obj_type,
            overloaded=data.get('overloaded', False),
            parsed_parameters=data.get('parsed_parameters', []),
            parsed_return_type=data.get('parsed_return_type'),
            extracted_calls=extracted_calls,
            start_line=start_line,
            end_line=end_line
        )
        
        # If an 'id' was present in the dictionary, assign it.
        # Otherwise, generate_id() will be called by the constructor or to_dict().
        # The current PLSQL_CodeObject constructor calls _cleanup_package_name and then
        # generate_id() is typically called by to_dict or when id is first accessed.
        # For deserialization, if an ID is provided, it should be used.
        if 'id' in data:
            code_object.id = data['id']
        else:
            # If no ID in dict, ensure it's generated to maintain consistency with to_dict
            code_object.generate_id() 

        return code_object